"""Property-based tests for authentication service"""

import pytest
from hypothesis import given, strategies as st, settings
from datetime import datetime, timedelta
from uuid import UUID
from app.core.security import (
    create_access_token,
    create_refresh_token,
    verify_token,
    decode_token,
    generate_api_key,
    hash_api_key,
    verify_api_key
)
from app.models.user import UserRole


# Custom strategies for generating test data
@st.composite
def user_id_strategy(draw):
    """Generate a valid UUID"""
    import uuid
    return uuid.uuid4()


@st.composite
def username_strategy(draw):
    """Generate a valid username"""
    return draw(st.text(
        alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd'), whitelist_characters='_-'),
        min_size=3,
        max_size=50
    ))


@st.composite
def role_strategy(draw):
    """Generate a valid user role"""
    return draw(st.sampled_from([UserRole.ADMIN, UserRole.DEVELOPER, UserRole.VIEWER]))


@st.composite
def permissions_strategy(draw):
    """Generate a list of permissions"""
    resources = ['mcps', 'knowledge', 'deployments', 'users', 'github', 'analyze']
    actions = ['create', 'read', 'update', 'delete']
    
    num_permissions = draw(st.integers(min_value=0, max_value=10))
    permissions = []
    for _ in range(num_permissions):
        resource = draw(st.sampled_from(resources))
        action = draw(st.sampled_from(actions))
        permissions.append(f"{resource}:{action}")
    
    return permissions


# Feature: mcp-platform-backend, Property 20: JWT Token Claims Completeness
@given(
    user_id=user_id_strategy(),
    username=username_strategy(),
    role=role_strategy(),
    permissions=permissions_strategy()
)
@settings(max_examples=100)
def test_jwt_token_claims_completeness(user_id, username, role, permissions):
    """
    For any valid user authentication, the generated JWT token should contain
    claims for user_id and roles.
    
    Validates: Requirements 6.1
    """
    # Create access token
    token = create_access_token(
        user_id=user_id,
        username=username,
        role=role,
        permissions=permissions
    )
    
    # Decode token
    payload = decode_token(token)
    
    # Assert token was created and decoded successfully
    assert payload is not None, "Token should be decodable"
    
    # Assert required claims are present
    assert "user_id" in payload, "Token should contain user_id claim"
    assert "role" in payload, "Token should contain role claim"
    assert "sub" in payload, "Token should contain sub (subject) claim"
    assert "exp" in payload, "Token should contain exp (expiration) claim"
    assert "iat" in payload, "Token should contain iat (issued at) claim"
    
    # Assert claim values match input
    assert payload["user_id"] == str(user_id), "user_id claim should match input"
    assert payload["username"] == username, "username claim should match input"
    assert payload["role"] == role.value, "role claim should match input"
    assert payload["permissions"] == permissions, "permissions claim should match input"


# Feature: mcp-platform-backend, Property 21: JWT Token Round-Trip Validation
@given(
    user_id=user_id_strategy(),
    username=username_strategy(),
    role=role_strategy(),
    permissions=permissions_strategy()
)
@settings(max_examples=100)
def test_jwt_token_round_trip_validation(user_id, username, role, permissions):
    """
    For any JWT token generated by the system, the token should validate
    successfully and return the original user_id within the expiry period.
    
    Validates: Requirements 6.2
    """
    # Create access token
    token = create_access_token(
        user_id=user_id,
        username=username,
        role=role,
        permissions=permissions
    )
    
    # Verify token (should succeed within expiry period)
    payload = verify_token(token)
    
    # Assert verification succeeded
    assert payload is not None, "Token should verify successfully within expiry period"
    
    # Assert user_id is preserved
    assert payload["user_id"] == str(user_id), "Verified token should return original user_id"
    assert payload["username"] == username, "Verified token should return original username"
    assert payload["role"] == role.value, "Verified token should return original role"


# Feature: mcp-platform-backend, Property 22: Expired Token Rejection
@given(
    user_id=user_id_strategy(),
    username=username_strategy(),
    role=role_strategy(),
    permissions=permissions_strategy()
)
@settings(max_examples=100)
def test_expired_token_rejection(user_id, username, role, permissions):
    """
    For any JWT token past its expiry time, accessing protected endpoints
    should return HTTP 401 status (token verification should fail).
    
    Validates: Requirements 6.3
    """
    # Create token with negative expiry (already expired)
    expired_delta = timedelta(seconds=-10)
    token = create_access_token(
        user_id=user_id,
        username=username,
        role=role,
        permissions=permissions,
        expires_delta=expired_delta
    )
    
    # Verify token (should fail because it's expired)
    payload = verify_token(token)
    
    # Assert verification failed
    assert payload is None, "Expired token should fail verification"


# Feature: mcp-platform-backend, Property 23: Authorization Permission Check
@given(
    role=role_strategy(),
    resource=st.sampled_from(['mcps', 'knowledge', 'deployments', 'users', 'github', 'analyze']),
    action=st.sampled_from(['create', 'read', 'update', 'delete'])
)
@settings(max_examples=100)
def test_authorization_permission_check(role, resource, action):
    """
    For any user and action beyond their role permissions, the request
    should be rejected with HTTP 403 status (permission check should fail).
    
    Validates: Requirements 6.4
    """
    from app.core.permissions import check_permission, ROLE_PERMISSIONS
    
    # Check permission
    has_permission = check_permission(role, resource, action)
    
    # Verify permission check is consistent with role permissions
    role_perms = ROLE_PERMISSIONS.get(role, [])
    
    # Admin should have all permissions
    if role == UserRole.ADMIN:
        assert has_permission, "Admin should have all permissions"
    
    # Check if permission exists in role's permission list
    expected_permission = f"{resource}:{action}"
    wildcard_resource = f"{resource}:*"
    wildcard_action = f"*:{action}"
    wildcard_all = "*:*"
    
    should_have_permission = (
        wildcard_all in role_perms or
        wildcard_resource in role_perms or
        wildcard_action in role_perms or
        expected_permission in role_perms
    )
    
    assert has_permission == should_have_permission, \
        f"Permission check for {role.value} on {resource}:{action} should match role permissions"


# Feature: mcp-platform-backend, Property 24: API Key Authentication
@given(
    num_keys=st.integers(min_value=1, max_value=10)
)
@settings(max_examples=100)
def test_api_key_authentication(num_keys):
    """
    For any valid API key, authentication should succeed and return
    the associated user.
    
    Validates: Requirements 6.5
    """
    # Generate multiple API keys and their hashes
    keys_and_hashes = []
    for _ in range(num_keys):
        api_key = generate_api_key()
        key_hash = hash_api_key(api_key)
        keys_and_hashes.append((api_key, key_hash))
    
    # Verify each key against its hash
    for api_key, key_hash in keys_and_hashes:
        assert verify_api_key(api_key, key_hash), \
            "API key should verify successfully against its hash"
    
    # Verify that wrong keys don't match
    if len(keys_and_hashes) > 1:
        wrong_key, correct_hash = keys_and_hashes[0][0], keys_and_hashes[1][1]
        assert not verify_api_key(wrong_key, correct_hash), \
            "Wrong API key should not verify against different hash"
